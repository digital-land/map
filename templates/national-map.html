{% extends "digital-land-frontend/dlf-base--full-width.html" %}

{% set includesMap = true %}
{% block pageTitle %}National map of planning data | Digital Land{% endblock %}

{%- block dlHead %}
<script src="./leaflet.permalink.min.js"></script>
{% endblock -%}

{% block content %}
<div class="govuk-grid-row">
	<div class="govuk-grid-column-full">
  	<h1 class="govuk-heading-xl">National map of planning data</h1>
    </div>
</div>

<p id="aria-label-national-map" class="govuk-body-l">National map of the planning data collected and collated by Digital Land.</p>

<div class="dl-map__wrapper">

  <div class="zoom-controls" data-module="zoom-controls">
    <button class="zoom-controls__btn" data-zoom-control="in">
      <span class="govuk-visually-hidden">Zoom in</span>
      <span>+</span>
    </button>
    <span class="zoom-controls__count-container" aria-live="polite">
      <span class="govuk-visually-hidden">The map is at zoom level </span>
      <span class="zoom-controls__count">6</span>
    </span>
    <button class="zoom-controls__btn" data-zoom-control="out">
      <span class="govuk-visually-hidden">Zoom out</span>
      <span>-</span>
    </button>
  </div>

  {% macro layerControlItem(layer) %}
  <li class="govuk-!-margin-bottom-2" data-layer-control="{{ layer.dataset }}" 
  {% if layer.active_zoom_level %}data-layer-control-zoom={{layer.active_zoom_level}}{% endif %} 
  {% if layer.colour %}data-layer-colour="{{ layer.colour }}"{% endif %}>
    <div class="govuk-checkboxes__item">
      <input class="govuk-checkboxes__input" id="{{ layer.dataset }}" name="{{ layer.dataset }}" type="checkbox" value="{{ layer.dataset }}" {{ "checked='checked'" if layer.checked }}>
      <label class="govuk-label govuk-checkboxes__label" for="{{ layer.dataset }}">
        {{ layer.label }}
        {% if layer.active_zoom_level %}
          <div class="dl-small-text secondary-text">From zoom level {{ layer.active_zoom_level }}</div>
        {% endif %}
      </label>
    </div>
  </li>
  {% endmacro %}

  <div id="mapid" style="height: 700px;" aria-labelledby="aria-label-national-map"></div>
  <div class="dl-map__side-panel dl-map__side-panel--full">
    <div class="dl-map__side-panel__heading">
      <h3 class="govuk-heading-s govuk-!-margin-bottom-0">Data layers</h3>
    </div>
    <div class="dl-map__side-panel__content">
      <ul class="govuk-list govuk-!-margin-bottom-0" data-module="layer-controls">
        {% for layer in layers %}
        {{ layerControlItem(layer) }}
        {% endfor %}
        {%- if layers_with_constraint|length %}
          <p class="govuk-body">Large datasets are only visible at zoom level <span data-layers-controls-zoom-constraint="10">10</span> or higher.</p>
        {% for layer in layers_with_constraint %}
        {{ layerControlItem(layer) }}
        {% endfor %}
        {% endif -%}
      </ul>
    </div>
  </div>
</div>
{% endblock %}

{% block bodyEnd %}
{{ super() }}
<script src="./layer-controls.js"></script>
<script src="./zoom-controls.js"></script>
<script>
  // callback used when layer control is clicked
  function toggleLayer(map, datasetName, add) {
    const layer = layerControlsComponent.layerMap[datasetName]
    if (add) {
      console.log("Debug: ", layer, datasetName)
      map.addLayer(layer)

      /* Not sure this is efficient
          What to limit the number of fetch requests. If layer toggled off then on
          with no move of the map there is no need to fetch all the features again */

      if (map._fetchSinceControlAction) {
        // if something has changed since layer last shown then trigger fetch all
        // can further improve by fetching only reenable layer
        fetchAll()
        map._fetchSinceControlAction = false
      }
      if (layer.getLayers().length === 0) {
        // if contains no layers then maybe no fetch has been done before
        fetchAll()
      }
    } else {
      map.removeLayer(layer)
    }
  }

  var mappos = L.Permalink.getMapLocation(6, [53.865, -5.101]);
  var theMap = L.map('mapid', {
    center: mappos.center,
    zoom: mappos.zoom
  });
  L.Permalink.setup(theMap);

  // setup the layer controls
  const $controlsList = document.querySelector('[data-module="layer-controls"]')
  const layerControlsComponent = new LayerControls($controlsList, theMap).init({
    toggleControlCallback: toggleLayer
  })

  // setup the zoom controls
  const $zoomControls = document.querySelector('[data-module="zoom-controls"]')
  const zoomControlsComponent = new ZoomControls($zoomControls, theMap, mappos.zoom).init({})

  // config
  var baseUrl = "https://datasette-demo.digital-land.info/view_model"
  var pageSize = 100

  // add the OpenStreetMap tiles
  L.tileLayer('https://tiles.wmflabs.org/bw-mapnik/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; <a href="https://openstreetmap.org/copyright">OpenStreetMap contributors</a>'
  }).addTo(theMap);

  let controller

  function abortAll() {
    controller.abort()
  }

  function fetchFeatures(progress, url, geoJsonLayer, signal, type_) {
    return new Promise((resolve, reject) => fetch(url, { signal })
      .then(response => {
          if (response.status !== 200)  {
            throw `${response.status}: ${response.statusText}`;
          }
          response.json().then(data => { 
            geoJsonLayer.addData(data)

            if(data.length >= pageSize) {
              progress && progress(geoJsonLayer, type_);
              lastItem = data[data.length - 1]
              let nextUrl = url
              nextUrl.searchParams.set("after", lastItem.id)
              fetchFeatures(progress, nextUrl, geoJsonLayer, signal, type_).then(resolve).catch(reject)
            } else {
              resolve(geoJsonLayer);
            }
          }).catch(reject);
      }).catch(reject));
    }

    function progressCallback(geoJsonLayer, type_) {
            console.debug(`${geoJsonLayer.getLayers().length} features fetched for ${type_}`);
    }

    function buildDataUrl(bounds, zoomLevel, type=false, after_rowid=0) {
      var query = "bounded_geography_simplified_paged"
      if (zoomLevel > 11) {query = "bounded_geography_full_paged"}
      if (type) {query = `${query}_by_type`}
      if (type == "brownfield-land") {query = "bounded_geography_brownfield_land"}

      url = new URL(`${baseUrl}/${query}.json?_json=geojson&_shape=arrayfirst&bbox_minx=${bounds._southWest.lng}&bbox_maxx=${bounds._northEast.lng}&bbox_miny=${bounds._southWest.lat}&bbox_maxy=${bounds._northEast.lat}&after=${after_rowid}`)

      if (type) url.searchParams.set("type", type)

      return url
    }

    function fetchAll(bounds=theMap.getBounds()) {
      if (controller) {
        console.log("controller.abort()")
        controller && controller.abort()
      }
      for (const [key, value] of Object.entries(layerControlsComponent.layerMap)) {
        value.clearLayers()
      }
      controller = new AbortController();
      layerControlsComponent.enabledLayers().forEach(layer => {
        let type_ = layer.dataset.layerControl
        let zoom = theMap.getZoom()
        let zoomConstraint = layerControlsComponent.getZoomRestriction(layer)

        // check for zoom constraint and only fetch if map is zoomed that far
        if(typeof zoomConstraint !== "undefined") {
          console.log(type_, "ZoomConstraint", layerControlsComponent.getZoomRestriction(layer))
          if (zoom < zoomConstraint) {return}
        }

        console.log("fetching", type_)
        fetchFeatures(progressCallback, buildDataUrl(bounds, zoom, type_), layerControlsComponent.layerMap[type_], controller.signal, type_).then(function (geoJsonLayer) {
          console.log("fetch complete", type_)
        }).catch((e) => {
          console.log("caught error from fetch", type_, e)
          console.error
        })
      })
    }

    theMap.on('moveend', function(event){
      var bounds = event.target.getBounds()
      fetchAll(bounds)
      theMap._fetchSinceControlAction = true
    });

    fetchAll()

</script>
{% endblock %}